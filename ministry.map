;;;; Hey, Emacs! This is a -*- lisp -*- file!
(in-package #:cataclysm)

;;; This nifty little utility was lifted from some code at
;;; http://hampshire.edu/lspector/
(defun shuffle (list)
  "Returns a randomly re-ordered copy of list."
  (let ((result nil))
    (do ()
	((null list) result)
      (let* ((which (random (length list)))
	     (it (nth which list)))
	(push it result)
	(setq list (remove it list :count 1))))))

(defvar *miniplenty-floor* (make-array 8 :initial-element nil))
(defvar *miniplenty-wall* (make-array 8 :initial-element nil))
(defvar *miniplenty-obstacle* (make-array 8 :initial-element nil))
(defvar *miniplenty-object* (make-array 8 :initial-element nil))
(defvar *miniplenty-portals* (make-array 8 :initial-element nil))
(defvar *miniplenty-messages* (make-array 8 :initial-element nil))
(defvar *miniplenty-start-up* (make-array 8 :initial-element nil))
(defvar *miniplenty-start-down* (make-array 8 :initial-element nil))

(defvar *minipax-floor* (make-array 8 :initial-element nil))
(defvar *minipax-wall* (make-array 8 :initial-element nil))
(defvar *minipax-obstacle* (make-array 8 :initial-element nil))
(defvar *minipax-object* (make-array 8 :initial-element nil))
(defvar *minipax-portals* (make-array 8 :initial-element nil))
(defvar *minipax-messages* (make-array 8 :initial-element nil))
(defvar *minipax-start-up* (make-array 8 :initial-element nil))
(defvar *minipax-start-down* (make-array 8 :initial-element nil))

(defvar *minitrue-floor* (make-array 8 :initial-element nil))
(defvar *minitrue-wall* (make-array 8 :initial-element nil))
(defvar *minitrue-obstacle* (make-array 8 :initial-element nil))
(defvar *minitrue-object* (make-array 8 :initial-element nil))
(defvar *minitrue-portals* (make-array 8 :initial-element nil))
(defvar *minitrue-messages* (make-array 8 :initial-element nil))
(defvar *minitrue-start-up* (make-array 8 :initial-element nil))
(defvar *minitrue-start-down* (make-array 8 :initial-element nil))

(defvar *miniluv-floor* (make-array 8 :initial-element nil))
(defvar *miniluv-wall* (make-array 8 :initial-element nil))
(defvar *miniluv-obstacle* (make-array 8 :initial-element nil))
(defvar *miniluv-object* (make-array 8 :initial-element nil))
(defvar *miniluv-portals* (make-array 8 :initial-element nil))
(defvar *miniluv-messages* (make-array 8 :initial-element nil))
(defvar *miniluv-start-up* (make-array 8 :initial-element nil))
(defvar *miniluv-start-down* (make-array 8 :initial-element nil))

;;; Has this dungeon been generated? If not, do it now
(defparameter *dungeon-map* (make-array '(9 9) :initial-element 0))

(defun get-neighbors (x y)
  (let (neighbors)
    (when (> x 1)
      (push 'N neighbors))
    (when (> y 1)
      (push 'W neighbors))
    (when (< x 8)
      (push 'S neighbors))
    (when (< y 8)
      (push 'E neighbors))
    neighbors))

(defun map-finished ()
  (let ((finished t))
    (dotimes (i 5)
      (dotimes (j 5)
	(when (= (aref *dungeon-map* (* 2 i) (* 2 j)) 0)
	  (setf finished nil))))
    finished))

(defun generate-map (x y)
  (setf (aref *dungeon-map* x y) 1)
  (when (map-finished)
    (setf (aref *dungeon-map* x y) 2))
  (let ((neighbors (shuffle (get-neighbors x y))))
    (dotimes (i (length neighbors))
      (case (nth i neighbors)
	(N
	 (when (= (aref *dungeon-map* (- x 2) y) 0)
	   (setf (aref *dungeon-map* (1- x) y) 1)
	   (generate-map (- x 2) y)))
	(S
	 (when (= (aref *dungeon-map* (+ x 2) y) 0)
	   (setf (aref *dungeon-map* (1+ x) y) 1)
	   (generate-map (+ x 2) y)))
	(E
	 (when (= (aref *dungeon-map* x (+ y 2)) 0)
	   (setf (aref *dungeon-map* x (1+ y)) 1)
	   (generate-map x (+ y 2))))
	(W
	 (when (= (aref *dungeon-map* x (- y 2)) 0)
	   (setf (aref *dungeon-map* x (1- y)) 1)
	   (generate-map x (- y 2))))))))

(defun room5x5 (floor-map wall-map x y exits)
  (dotimes (i 5)
    (dotimes (j 5)
      (setf (aref floor-map (+ x i 5) (+ y j 5)) 0)
      (when (or (= i 0) (= j 0) (= i 4) (= j 4))
	(setf (aref wall-map (+ x i 5) (+ y j 5)) 20))))
  (when (find 'N exits)
    (setf (aref wall-map (+ x 7) (+ y 5)) -1)
    (dotimes (i 5)
      (setf (aref floor-map (+ x 7) (+ y i)) 0)
      (setf (aref wall-map (+ x 6) (+ y i)) 20)
      (setf (aref wall-map (+ x 8) (+ y i)) 20)))
  (when (find 'S exits)
    (setf (aref wall-map (+ x 7) (+ y 9)) -1)
    (dotimes (i 5)
      (setf (aref floor-map (+ x 7) (+ 10 y i)) 0)
      (setf (aref wall-map (+ x 6) (+ 10 y i)) 20)
      (setf (aref wall-map (+ x 8) (+ 10 y i)) 20)))
  (when (find 'E exits)
    (setf (aref wall-map (+ x 9) (+ y 7)) -1)
    (dotimes (i 5)
      (setf (aref floor-map (+ 10 x i) (+ y 7)) 0)
      (setf (aref wall-map (+ 10 x i) (+ y 6)) 20)
      (setf (aref wall-map (+ 10 x i) (+ y 8)) 20)))
  (when (find 'W exits)
    (setf (aref wall-map (+ x 5) (+ y 7)) -1)
    (dotimes (i 5)
      (setf (aref floor-map (+ x i) (+ y 7)) 0)
      (setf (aref wall-map (+ x i) (+ y 6)) 20)
      (setf (aref wall-map (+ x i) (+ y 8)) 20))))


(defun room7x7 (floor-map wall-map x y exits)
  (dotimes (i 7)
    (dotimes (j 7)
      (setf (aref floor-map (+ x i 4) (+ y j 4)) 0)
      (when (or (= i 0) (= j 0) (= i 6) (= j 6))
	(setf (aref wall-map (+ x i 4) (+ y j 4)) 20))))
  (when (find 'N exits)
    (setf (aref wall-map (+ x 7) (+ y 4)) -1)
    (dotimes (i 4)
      (setf (aref floor-map (+ x 7) (+ y i)) 0)
      (setf (aref wall-map (+ x 6) (+ y i)) 20)
      (setf (aref wall-map (+ x 8) (+ y i)) 20)))
  (when (find 'S exits)
    (setf (aref wall-map (+ x 7) (+ y 10)) -1)
    (dotimes (i 4)
      (setf (aref floor-map (+ x 7) (+ 11 y i)) 0)
      (setf (aref wall-map (+ x 6) (+ 11 y i)) 20)
      (setf (aref wall-map (+ x 8) (+ 11 y i)) 20)))
  (when (find 'E exits)
    (setf (aref wall-map (+ x 10) (+ y 7)) -1)
    (dotimes (i 4)
      (setf (aref floor-map (+ 11 x i) (+ y 7)) 0)
      (setf (aref wall-map (+ 11 x i) (+ y 6)) 20)
      (setf (aref wall-map (+ 11 x i) (+ y 8)) 20)))
  (when (find 'W exits)
    (setf (aref wall-map (+ x 4) (+ y 7)) -1)
    (dotimes (i 4)
      (setf (aref floor-map (+ x i) (+ y 7)) 0)
      (setf (aref wall-map (+ x i) (+ y 6)) 20)
      (setf (aref wall-map (+ x i) (+ y 8)) 20))))

(defun room15x15 (floor-map wall-map x y exits)
  (dotimes (i 15)
    (dotimes (j 15)
      (setf (aref floor-map (+ x i) (+ y j)) 0)
      (when (or (= i 0) (= j 0) (= i 14) (= j 14))
	(setf (aref wall-map (+ x i) (+ y j)) 20))))
  (when (find 'N exits)
    (setf (aref wall-map (+ x 7) y) -1))
  (when (find 'S exits)
    (setf (aref wall-map (+ x 7) (+ y 14)) -1))
  (when (find 'E exits)
    (setf (aref wall-map (+ x 14) (+ y 7)) -1))
  (when (find 'W exits)
    (setf (aref wall-map x (+ y 7)) -1)))

(defun create-room (floor-map wall-map x y exits)
  (case (random 3)
    (0 (room5x5 floor-map wall-map x y exits))
    (1 (room7x7 floor-map wall-map x y exits))
    (otherwise (room15x15 floor-map wall-map x y exits))))

(defun create-dungeon-miniplenty ()
  (let ((start-x (random 5)) (start-y (random 5)) (end-x 0) (end-y 0))
    (when (= *current-floor* 0)
      (setf start-x 2 start-y 4))
    (generate-map (* start-x 2) (* start-y 2))
    (setf (aref *miniplenty-floor* *current-floor*) (make-array '(75 75) :initial-element 13))
    (setf (aref *miniplenty-wall* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *miniplenty-obstacle* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *miniplenty-object* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *miniplenty-portals* *current-floor*) (make-array '(75 75) :initial-element nil))
    (setf (aref *miniplenty-messages* *current-floor*) (make-array '(75 75) :initial-element nil))
    (dotimes (i 5)
      (dotimes (j 5)
	(when (> (aref *dungeon-map* (* 2 i) (* 2 j)) 1)
	  (setf end-x i end-y j))
	(let ((exits nil))
	  (when (and (< i 4)
		     (> (aref *dungeon-map* (1+ (* 2 i)) (* 2 j)) 0))
	    (push 'E exits))
	  (when (and (> i 0)
		     (> (aref *dungeon-map* (1- (* 2 i)) (* 2 j)) 0))
	    (push 'W exits))
	  (when (and (< j 4)
		     (> (aref *dungeon-map* (* 2 i) (1+ (* 2 j))) 0))
	    (push 'S exits))
	  (when (and (> j 0)
		     (> (aref *dungeon-map* (* 2 i) (1- (* 2 j))) 0))
	    (push 'N exits))
	  (create-room (aref *miniplenty-floor* *current-floor*) (aref *miniplenty-wall* *current-floor*)
		       (* i 15) (* j 15) exits))))
    (setf (aref *miniplenty-start-down* *current-floor*)
	  (list (* (+ (* start-x 15) 7) 32)
		(* (+ (* start-y 15) 7) 32)))
    (setf (aref *miniplenty-start-up* *current-floor*)
	  (list (+ (* (+ (* end-x 15) 7) 32) 16)
		(+ (* (+ (* end-y 15) 7) 32) 16)))
    (when (= *current-floor* 0)
      (setf (aref *miniplenty-start-down* 0) '(1200 2352)))
    (dotimes (i 75)
      (dotimes (j 75)
	(let ((k (random 2000)))
	  (when (and (= (aref (aref *miniplenty-floor* *current-floor*) i j) 0)
		     (< (aref (aref *miniplenty-wall* *current-floor*) i j) 0)
		     (< k 10))
	    (cond
	      ((< k 1)
	       (setf (aref (aref *miniplenty-object* *current-floor*) i j) 45))
	      ((< k 2)
	       (setf (aref (aref *miniplenty-object* *current-floor*) i j) 44))
	      ((< k 4)
	       (setf (aref (aref *miniplenty-object* *current-floor*) i j) 43))
	      ((< k 6)
	       (setf (aref (aref *miniplenty-object* *current-floor*) i j) 42))
	      (t
	       (setf (aref (aref *miniplenty-object* *current-floor*) i j) 41)))))))

    (when (and (= *current-floor* 7)
	       (eq *current-dungeon* *key-location*))
      (setf (aref (aref *miniplenty-object* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 40))

    (when (and (= *current-floor* 7)
	       (eq *current-dungeon* *crown-location*))
      (setf (aref (aref *miniplenty-object* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 59)
      (setf (aref (aref *miniplenty-obstacle* *current-floor*)
		  (+ (* end-x 15) 6)
		  (+ (* end-y 15) 7)) 60
	    (aref (aref *miniplenty-obstacle* *current-floor*)
		  (+ (* end-x 15) 8)
		  (+ (* end-y 15) 7)) 60
	    (aref (aref *miniplenty-obstacle* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 6)) 60
	    (aref (aref *miniplenty-obstacle* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 8)) 60))
    (when (< *current-floor* 7)
      (setf (aref (aref *miniplenty-floor* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 1
	    (aref (aref *miniplenty-portals* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 'floor-down))
    (when (> *current-floor* 0)
      (setf (aref (aref *miniplenty-floor* *current-floor*)
		  (+ (* start-x 15) 7)
		  (+ (* start-y 15) 7)) 2
	    (aref (aref *miniplenty-portals* *current-floor*)
		  (+ (* start-x 15) 7)
		  (+ (* start-y 15) 7)) 'floor-up))
    (when (= *current-floor* 0)
      (dotimes (i 7)
	(setf (aref (aref *miniplenty-floor* *current-floor*) 37 (+ i 67)) 0)
	(setf (aref (aref *miniplenty-wall* *current-floor*) 37 (+ i 68)) -1)
	(setf (aref (aref *miniplenty-wall* *current-floor*) 36 (+ i 68)) 20)
	(setf (aref (aref *miniplenty-wall* *current-floor*) 38 (+ i 68)) 20))
      (setf (aref (aref *miniplenty-portals* *current-floor*) 37 74) 'overworld))))

(defun create-dungeon-minipax ()
  (let ((start-x (random 5)) (start-y (random 5)) (end-x 0) (end-y 0))
    (when (= *current-floor* 0)
      (setf start-x 2 start-y 4))
    (generate-map (* start-x 2) (* start-y 2))
    (setf (aref *minipax-floor* *current-floor*) (make-array '(75 75) :initial-element 13))
    (setf (aref *minipax-wall* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *minipax-obstacle* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *minipax-object* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *minipax-portals* *current-floor*) (make-array '(75 75) :initial-element nil))
    (setf (aref *minipax-messages* *current-floor*) (make-array '(75 75) :initial-element nil))
    (dotimes (i 5)
      (dotimes (j 5)
	(when (> (aref *dungeon-map* (* 2 i) (* 2 j)) 1)
	  (setf end-x i end-y j))
	(let ((exits nil))
	  (when (and (< i 4)
		     (> (aref *dungeon-map* (1+ (* 2 i)) (* 2 j)) 0))
	    (push 'E exits))
	  (when (and (> i 0)
		     (> (aref *dungeon-map* (1- (* 2 i)) (* 2 j)) 0))
	    (push 'W exits))
	  (when (and (< j 4)
		     (> (aref *dungeon-map* (* 2 i) (1+ (* 2 j))) 0))
	    (push 'S exits))
	  (when (and (> j 0)
		     (> (aref *dungeon-map* (* 2 i) (1- (* 2 j))) 0))
	    (push 'N exits))
	  (create-room (aref *minipax-floor* *current-floor*) (aref *minipax-wall* *current-floor*)
		       (* i 15) (* j 15) exits))))
    (setf (aref *minipax-start-down* *current-floor*)
	  (list (+ (* (+ (* start-x 15) 7) 32) 16)
		(+ (* (+ (* start-y 15) 7) 32) 16)))
    (setf (aref *minipax-start-up* *current-floor*)
	  (list (+ (* (+ (* end-x 15) 7) 32) 16)
		(+ (* (+ (* end-y 15) 7) 32) 16)))
    (when (= *current-floor* 0)
      (setf (aref *minipax-start-down* 0) '(1200 2352)))
    (dotimes (i 75)
      (dotimes (j 75)
	(let ((k (random 2000)))
	  (when (and (= (aref (aref *minipax-floor* *current-floor*) i j) 0)
		     (< (aref (aref *minipax-wall* *current-floor*) i j) 0)
		     (< k 10))
	    (cond
	      ((< k 1)
	       (setf (aref (aref *minipax-object* *current-floor*) i j) 45))
	      ((< k 3)
	       (setf (aref (aref *minipax-object* *current-floor*) i j) 44))
	      ((< k 5)
	       (setf (aref (aref *minipax-object* *current-floor*) i j) 43))
	      ((< k 7)
	       (setf (aref (aref *minipax-object* *current-floor*) i j) 42))
	      (t
	       (setf (aref (aref *minipax-object* *current-floor*) i j) 41)))))))

    (when (and (= *current-floor* 7)
	       (eq *current-dungeon* *key-location*))
      (setf (aref (aref *minipax-object* *current-floor*)
		  (- (* end-x 15) 7)
		  (- (* end-y 15) 7)) 40))

    (when (and (= *current-floor* 7)
	       (eq *current-dungeon* *crown-location*))
      (setf (aref (aref *minipax-object* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 59)
      (setf (aref (aref *minipax-obstacle* *current-floor*)
		  (+ (* end-x 15) 6)
		  (+ (* end-y 15) 7)) 60
	    (aref (aref *minipax-obstacle* *current-floor*)
		  (+ (* end-x 15) 8)
		  (+ (* end-y 15) 7)) 60
	    (aref (aref *minipax-obstacle* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 6)) 60
	    (aref (aref *minipax-obstacle* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 8)) 60))
    (when (< *current-floor* 7)
      (setf (aref (aref *minipax-floor* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 1
	    (aref (aref *minipax-portals* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 'floor-down))
    (when (> *current-floor* 0)
      (setf (aref (aref *minipax-floor* *current-floor*)
		  (+ (* start-x 15) 7)
		  (+ (* start-y 15) 7)) 2
	    (aref (aref *minipax-portals* *current-floor*)
		  (+ (* start-x 15) 7)
		  (+ (* start-y 15) 7)) 'floor-up))
    (when (= *current-floor* 0)
      (dotimes (i 7)
	(setf (aref (aref *minipax-floor* *current-floor*) 37 (+ i 67)) 0)
	(setf (aref (aref *minipax-wall* *current-floor*) 37 (+ i 68)) -1)
	(setf (aref (aref *minipax-wall* *current-floor*) 36 (+ i 68)) 20)
	(setf (aref (aref *minipax-wall* *current-floor*) 38 (+ i 68)) 20))
      (setf (aref (aref *minipax-portals* *current-floor*) 37 74) 'overworld))))

(defun create-dungeon-minitrue ()
  (let ((start-x (random 5)) (start-y (random 5)) (end-x 0) (end-y 0))
    (when (= *current-floor* 0)
      (setf start-x 2 start-y 4))
    (generate-map (* start-x 2) (* start-y 2))
    (setf (aref *minitrue-floor* *current-floor*) (make-array '(75 75) :initial-element 13))
    (setf (aref *minitrue-wall* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *minitrue-obstacle* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *minitrue-object* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *minitrue-portals* *current-floor*) (make-array '(75 75) :initial-element nil))
    (setf (aref *minitrue-messages* *current-floor*) (make-array '(75 75) :initial-element nil))
    (dotimes (i 5)
      (dotimes (j 5)
	(when (> (aref *dungeon-map* (* 2 i) (* 2 j)) 1)
	  (setf end-x i end-y j))
	(let ((exits nil))
	  (when (and (< i 4)
		     (> (aref *dungeon-map* (1+ (* 2 i)) (* 2 j)) 0))
	    (push 'E exits))
	  (when (and (> i 0)
		     (> (aref *dungeon-map* (1- (* 2 i)) (* 2 j)) 0))
	    (push 'W exits))
	  (when (and (< j 4)
		     (> (aref *dungeon-map* (* 2 i) (1+ (* 2 j))) 0))
	    (push 'S exits))
	  (when (and (> j 0)
		     (> (aref *dungeon-map* (* 2 i) (1- (* 2 j))) 0))
	    (push 'N exits))
	  (create-room (aref *minitrue-floor* *current-floor*) (aref *minitrue-wall* *current-floor*)
		       (* i 15) (* j 15) exits))))
    (setf (aref *minitrue-start-down* *current-floor*)
	  (list (+ (* (+ (* start-x 15) 7) 32) 16)
		(+ (* (+ (* start-y 15) 7) 32) 16)))
    (setf (aref *minitrue-start-up* *current-floor*)
	  (list (+ (* (+ (* end-x 15) 7) 32) 16)
		(+ (* (+ (* end-y 15) 7) 32) 16)))
    (when (= *current-floor* 0)
      (setf (aref *minitrue-start-down* 0) '(1200 2352)))
    (dotimes (i 75)
      (dotimes (j 75)
	(let ((k (random 2000)))
	  (when (and (= (aref (aref *minitrue-floor* *current-floor*) i j) 0)
		     (< (aref (aref *minitrue-wall* *current-floor*) i j) 0)
		     (< k 10))
	    (cond
	      ((< k 1)
	       (setf (aref (aref *minitrue-object* *current-floor*) i j) 45))
	      ((< k 3)
	       (setf (aref (aref *minitrue-object* *current-floor*) i j) 44))
	      ((< k 5)
	       (setf (aref (aref *minitrue-object* *current-floor*) i j) 43))
	      ((< k 7)
	       (setf (aref (aref *minitrue-object* *current-floor*) i j) 42))
	      (t
	       (setf (aref (aref *minitrue-object* *current-floor*) i j) 41)))))))

    (when (and (= *current-floor* 7)
	       (eq *current-dungeon* *key-location*))
      (setf (aref (aref *minitrue-object* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 40))

    (when (and (= *current-floor* 7)
	       (eq *current-dungeon* *crown-location*))
      (setf (aref (aref *minitrue-object* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 59)
      (setf (aref (aref *minitrue-obstacle* *current-floor*)
		  (+ (* end-x 15) 6)
		  (+ (* end-y 15) 7)) 60
	    (aref (aref *minitrue-obstacle* *current-floor*)
		  (+ (* end-x 15) 8)
		  (+ (* end-y 15) 7)) 60
	    (aref (aref *minitrue-obstacle* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 6)) 60
	    (aref (aref *minitrue-obstacle* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 8)) 60))
    (when (< *current-floor* 7)
      (setf (aref (aref *minitrue-floor* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 1
	    (aref (aref *minitrue-portals* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 'floor-down))
    (when (> *current-floor* 0)
      (setf (aref (aref *minitrue-floor* *current-floor*)
		  (+ (* start-x 15) 7)
		  (+ (* start-y 15) 7)) 2
	    (aref (aref *minitrue-portals* *current-floor*)
		  (+ (* start-x 15) 7)
		  (+ (* start-y 15) 7)) 'floor-up))
    (when (= *current-floor* 0)
      (dotimes (i 7)
	(setf (aref (aref *minitrue-floor* *current-floor*) 37 (+ i 67)) 0)
	(setf (aref (aref *minitrue-wall* *current-floor*) 37 (+ i 68)) -1)
	(setf (aref (aref *minitrue-wall* *current-floor*) 36 (+ i 68)) 20)
	(setf (aref (aref *minitrue-wall* *current-floor*) 38 (+ i 68)) 20))
      (setf (aref (aref *minitrue-portals* *current-floor*) 37 74) 'overworld))))

(defun create-dungeon-miniluv ()
  (let ((start-x (random 5)) (start-y (random 5)) (end-x 0) (end-y 0))
    (when (= *current-floor* 0)
      (setf start-x 2 start-y 4))
    (generate-map (* start-x 2) (* start-y 2))
    (setf (aref *miniluv-floor* *current-floor*) (make-array '(75 75) :initial-element 13))
    (setf (aref *miniluv-wall* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *miniluv-obstacle* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *miniluv-object* *current-floor*) (make-array '(75 75) :initial-element -1))
    (setf (aref *miniluv-portals* *current-floor*) (make-array '(75 75) :initial-element nil))
    (setf (aref *miniluv-messages* *current-floor*) (make-array '(75 75) :initial-element nil))
    (dotimes (i 5)
      (dotimes (j 5)
	(when (> (aref *dungeon-map* (* 2 i) (* 2 j)) 1)
	  (setf end-x i end-y j))
	(let ((exits nil))
	  (when (and (< i 4)
		     (> (aref *dungeon-map* (1+ (* 2 i)) (* 2 j)) 0))
	    (push 'E exits))
	  (when (and (> i 0)
		     (> (aref *dungeon-map* (1- (* 2 i)) (* 2 j)) 0))
	    (push 'W exits))
	  (when (and (< j 4)
		     (> (aref *dungeon-map* (* 2 i) (1+ (* 2 j))) 0))
	    (push 'S exits))
	  (when (and (> j 0)
		     (> (aref *dungeon-map* (* 2 i) (1- (* 2 j))) 0))
	    (push 'N exits))
	  (create-room (aref *miniluv-floor* *current-floor*) (aref *miniluv-wall* *current-floor*)
		       (* i 15) (* j 15) exits))))
    (setf (aref *miniluv-start-down* *current-floor*)
	  (list (+ (* (+ (* start-x 15) 7) 32) 16)
		(+ (* (+ (* start-y 15) 7) 32) 16)))
    (setf (aref *miniluv-start-up* *current-floor*)
	  (list (+ (* (+ (* end-x 15) 7) 32) 16)
		(+ (* (+ (* end-y 15) 7) 32) 16)))
    (when (= *current-floor* 0)
      (setf (aref *miniluv-start-down* 0) '(1200 2352)))
    (dotimes (i 75)
      (dotimes (j 75)
	(let ((k (random 2000)))
	  (when (and (= (aref (aref *miniluv-floor* *current-floor*) i j) 0)
		     (< (aref (aref *miniluv-wall* *current-floor*) i j) 0)
		     (< k 10))
	    (cond
	      ((< k 1)
	       (setf (aref (aref *miniluv-object* *current-floor*) i j) 45))
	      ((< k 3)
	       (setf (aref (aref *miniluv-object* *current-floor*) i j) 44))
	      ((< k 5)
	       (setf (aref (aref *miniluv-object* *current-floor*) i j) 43))
	      ((< k 7)
	       (setf (aref (aref *miniluv-object* *current-floor*) i j) 42))
	      (t
	       (setf (aref (aref *miniluv-object* *current-floor*) i j) 41)))))))

    (when (and (= *current-floor* 7)
	       (eq *current-dungeon* *key-location*))
      (setf (aref (aref *miniluv-object* *current-floor*)
		  (- (* end-x 15) 7)
		  (- (* end-y 15) 7)) 40))

    (when (and (= *current-floor* 7)
	       (eq *current-dungeon* *crown-location*))
      (setf (aref (aref *miniluv-object* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 59)
      (setf (aref (aref *miniluv-obstacle* *current-floor*)
		  (+ (* end-x 15) 6)
		  (+ (* end-y 15) 7)) 60
	    (aref (aref *miniluv-obstacle* *current-floor*)
		  (+ (* end-x 15) 8)
		  (+ (* end-y 15) 7)) 60
	    (aref (aref *miniluv-obstacle* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 6)) 60
	    (aref (aref *miniluv-obstacle* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 8)) 60))
    (when (< *current-floor* 7)
      (setf (aref (aref *miniluv-floor* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 1
	    (aref (aref *miniluv-portals* *current-floor*)
		  (+ (* end-x 15) 7)
		  (+ (* end-y 15) 7)) 'floor-down))
    (when (> *current-floor* 0)
      (setf (aref (aref *miniluv-floor* *current-floor*)
		  (+ (* start-x 15) 7)
		  (+ (* start-y 15) 7)) 2
	    (aref (aref *miniluv-portals* *current-floor*)
		  (+ (* start-x 15) 7)
		  (+ (* start-y 15) 7)) 'floor-up))
    (when (= *current-floor* 0)
      (dotimes (i 7)
	(setf (aref (aref *miniluv-floor* *current-floor*) 37 (+ i 67)) 0)
	(setf (aref (aref *miniluv-wall* *current-floor*) 37 (+ i 68)) -1)
	(setf (aref (aref *miniluv-wall* *current-floor*) 36 (+ i 68)) 20)
	(setf (aref (aref *miniluv-wall* *current-floor*) 38 (+ i 68)) 20))
      (setf (aref (aref *miniluv-portals* *current-floor*) 37 74) 'overworld))))

(defun dungeon-select ()
  ;;; find out which dungeon we're in, if we just entered
  (unless *current-dungeon*
    (cond
      ((and (> (x-position *player*) 720) (> (y-position *player*) 400))
       (setf *current-dungeon* 'miniluv))
      ((> (x-position *player*) 720) (setf *current-dungeon* 'minitrue))
      ((> (y-position *player*) 400) (setf *current-dungeon* 'minipax))
      (t (setf *current-dungeon* 'miniplenty))))

  ;;;; set current map to appropriate dungeon and floor
  (setf *map-width* 75)
  (setf *map-height* 75)
  (case *current-dungeon*
    (miniplenty
     (when (null (aref *miniplenty-floor* *current-floor*))
       (create-dungeon-miniplenty))
     (setf *floor-map* (aref *miniplenty-floor* *current-floor*))
     (setf *wall-map* (aref *miniplenty-wall* *current-floor*))
     (setf *obstacle-map* (aref *miniplenty-obstacle* *current-floor*))
     (setf *object-map* (aref *miniplenty-object* *current-floor*))
     (setf *portals* (aref *miniplenty-portals* *current-floor*))
     (setf *messages* (aref *miniplenty-messages* *current-floor*))
     (cond ((eq *from* 'above)
	    (setf (x-position *player*) (first (aref *miniplenty-start-down*
						     *current-floor*)))
	    (setf (y-position *player*) (second (aref *miniplenty-start-down*
						      *current-floor*))))
	   (t
	    (setf (x-position *player*) (first (aref *miniplenty-start-up*
						     *current-floor*)))
	    (setf (y-position *player*) (second (aref *miniplenty-start-up*
						      *current-floor*))))))	  
    (minipax
     (when (null (aref *minipax-floor* *current-floor*))
       (create-dungeon-minipax))
     (setf *floor-map* (aref *minipax-floor* *current-floor*))
     (setf *wall-map* (aref *minipax-wall* *current-floor*))
     (setf *obstacle-map* (aref *minipax-obstacle* *current-floor*))
     (setf *object-map* (aref *minipax-object* *current-floor*))
     (setf *portals* (aref *minipax-portals* *current-floor*))
     (setf *messages* (aref *minipax-messages* *current-floor*))
     (cond ((eq *from* 'above)
	    (setf (x-position *player*) (first (aref *minipax-start-down*
						     *current-floor*)))
	    (setf (y-position *player*) (second (aref *minipax-start-down*
						      *current-floor*))))
	   (t
	    (setf (x-position *player*) (first (aref *minipax-start-up*
						     *current-floor*)))
	    (setf (y-position *player*) (second (aref *minipax-start-up*
						      *current-floor*))))))	  
    
    (minitrue
     (when (null (aref *minitrue-floor* *current-floor*))
       (create-dungeon-minitrue))
     (setf *floor-map* (aref *minitrue-floor* *current-floor*))
     (setf *wall-map* (aref *minitrue-wall* *current-floor*))
     (setf *obstacle-map* (aref *minitrue-obstacle* *current-floor*))
     (setf *object-map* (aref *minitrue-object* *current-floor*))
     (setf *portals* (aref *minitrue-portals* *current-floor*))
     (setf *messages* (aref *minitrue-messages* *current-floor*))
     (cond ((eq *from* 'above)
	    (setf (x-position *player*) (first (aref *minitrue-start-down*
						     *current-floor*)))
	    (setf (y-position *player*) (second (aref *minitrue-start-down*
						      *current-floor*))))
	   (t
	    (setf (x-position *player*) (first (aref *minitrue-start-up*
						     *current-floor*)))
	    (setf (y-position *player*) (second (aref *minitrue-start-up*
						      *current-floor*))))))	  
    
    (miniluv
     (when (null (aref *miniluv-floor* *current-floor*))
       (create-dungeon-miniluv))
     (setf *floor-map* (aref *miniluv-floor* *current-floor*))
     (setf *wall-map* (aref *miniluv-wall* *current-floor*))
     (setf *obstacle-map* (aref *miniluv-obstacle* *current-floor*))
     (setf *object-map* (aref *miniluv-object* *current-floor*))
     (setf *portals* (aref *miniluv-portals* *current-floor*))
     (setf *messages* (aref *miniluv-messages* *current-floor*))
     (cond ((eq *from* 'above)
	    (setf (x-position *player*) (first (aref *miniluv-start-down*
						     *current-floor*)))
	    (setf (y-position *player*) (second (aref *miniluv-start-down*
						      *current-floor*))))
	   (t
	    (setf (x-position *player*) (first (aref *miniluv-start-up*
						     *current-floor*)))
	    (setf (y-position *player*) (second (aref *miniluv-start-up*
						      *current-floor*)))))))
  
  
  ;;;; Place appropriate enemies
  (setf *enemies* nil)
  (dotimes (i 75)
    (dotimes (j 75)
      (when (and
	     (not (= (aref *floor-map* i j) 13))
	     (< (aref *wall-map* i j) 0)
	     (> (abs (- (* 32 i) (x-position *player*))) 64)
	     (> (abs (- (* 32 j) (y-position *player*))) 64)
	     (< (random 175) (1+ *current-floor*)))
	(push (make-instance 'enemy :x-position (+ (* 32 i) 16)
			     :y-position (+ (* 32 j) 16)
			     :direction 'down :moving t
			     :hit-points (1+ *current-floor*)
			     :sprite (* 20 (1+ *current-floor*)))
	      *enemies*)))))

(defun floor-down-select ()
  (incf *current-floor*)
  (setf *from* 'above)
  (dungeon-select))

(defun floor-up-select ()
  (decf *current-floor*)
  (setf *from* 'below)
  (dungeon-select))

(add-map (make-instance 'world-map
			:map-name 'ministry
			:tileset *tileset*
			:map-width *map-width*
			:map-height *map-height*
			:floor-map *floor-map*
			:wall-map *wall-map*
			:obstacle-map *obstacle-map*
			:object-map *object-map*
			:portals *portals*
			:messages *messages*))

(add-map (make-instance 'world-map
			:map-name 'floor-up
			:tileset *tileset*
			:map-width *map-width*
			:map-height *map-height*
			:floor-map *floor-map*
			:wall-map *wall-map*
			:obstacle-map *obstacle-map*
			:object-map *object-map*
			:portals *portals*
			:messages *messages*))

(add-map (make-instance 'world-map
			:map-name 'floor-down
			:tileset *tileset*
			:map-width *map-width*
			:map-height *map-height*
			:floor-map *floor-map*
			:wall-map *wall-map*
			:obstacle-map *obstacle-map*
			:object-map *object-map*
			:portals *portals*
			:messages *messages*))

(register-select-function 'ministry 'dungeon-select)
(register-select-function 'floor-up 'floor-up-select)
(register-select-function 'floor-down 'floor-down-select)
